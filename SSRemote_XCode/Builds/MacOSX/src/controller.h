/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#ifndef PLUGINPROCESSOR_H_INCLUDED
#define PLUGINPROCESSOR_H_INCLUDED

#include "../JuceLibraryCode/JuceHeader.h"


//Own classes
#include <src/utils/jack_client.h>
#include <src/utils/tcp_connection.h>
#include <src/utils/ssr_requester.h>
#include <src/parameter/parameter.h>
#include <src/config/config.h>
#include <src/utils/update_specificator.h>
#include <src/scene/scene.h>

//==============================================================================
/**
*/
class Controller  : public AudioProcessor
{
public:
    //==============================================================================
    Controller();
    ~Controller();

    //==============================================================================
    void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    void releaseResources() override;

    void processBlock (AudioSampleBuffer&, MidiBuffer&) override;

    //==============================================================================
    AudioProcessorEditor* createEditor() override;
    bool hasEditor() const override;

    //==============================================================================
    const String getName() const override;

    const String getInputChannelName (int channelIndex) const override;
    const String getOutputChannelName (int channelIndex) const override;
    bool isInputChannelStereoPair (int index) const override;
    bool isOutputChannelStereoPair (int index) const override;

    bool acceptsMidi() const override;
    bool producesMidi() const override;
    bool silenceInProducesSilenceOut() const override;
    double getTailLengthSeconds() const override;

    //==============================================================================
    int getNumPrograms() override;
    int getCurrentProgram() override;
    void setCurrentProgram (int index) override;
    const String getProgramName (int index) override;
    void changeProgramName (int index, const String& newName) override;

    //==============================================================================
    void getStateInformation (MemoryBlock& destData) override;
    void setStateInformation (const void* data, int sizeInBytes) override;
    
    
    int getParameterNumSteps(int parameterIndex);

    /**
     * Returns the number of parameters.
     *
     * @see source.h
     * @see enum parameter
     *
     * JUCE Doc.:
     *
     * This must return the correct value immediately after the object has been
     * created, and mustn't change the number of parameters later.
     *
     * NOTE! This method will eventually be deprecated! It's recommended that you
     * use the AudioProcessorParameter class instead to manage your parameters.
     *
     * @see http://learn.juce.com/doc/classAudioProcessor.php#ac7b802374ba30b719f34570ab6f07c21
     *
     * @return the number of parameters.
     */
    int getNumParameters() override;
    
    /**
     * Returns the parameters name identified by the transferred parameterIndex.
     *
     * JUCE Doc.:
     *
     * Returns the name of a particular parameter.
     *
     * NOTE! This method will eventually be deprecated! It's recommended that you
     * use the AudioProcessorParameter class instead to manage your parameters.
     *
     * @see http://learn.juce.com/doc/classAudioProcessor.php#a9ae35eca716774ae1fd750d60c52885e
     *
     * @param     parameterIndex          The index of the parameter which name
     *                                    shall be returned.
     *
     * @return the parameters name identified by the parameterIndex.
     **/
    const String getParameterName (int parameterIndex) override;
    
    /**
     * Returns the parameter value identified by the transferred index.
     *
     * @see source.h
     * @see scene.h
     *
     * JUCE Doc.:
     *
     * Called by the host to find out the value of one of the filter's parameters.
     *
     * The host will expect the value returned to be between 0 and 1.0.
     *
     * This could be called quite frequently, so try to make your code efficient.
     * It's also likely to be called by non-UI threads, so the code in here
     * should be thread-aware.
     *
     * NOTE! This method will eventually be deprecated! It's recommended that you
     * use the AudioProcessorParameter class instead to manage your parameters.
     *
     * @see http://learn.juce.com/doc/classAudioProcessor.php#aa4b04d76a2d80c08f0d762f0fa6b715c
     *
     * @param     index           The index of the parameter which value shall be
     *                            returned.
     *
     * @return the parameter value identified by the transferred index.
     **/
    float getParameter(int index) override;
    
    /**
     * Return the parameters value identified by the transferred index as
     * a String.
     *
     * If the index is not supported, the Method will return "0.0".
     *
     * JUCE Doc.:
     *
     * Returns the value of a parameter as a text string.
     *
     * NOTE! This method will eventually be deprecated! It's recommended that
     * you use AudioProcessorParameter::getText() instead.
     *
     * @see http://learn.juce.com/doc/classAudioProcessor.php#adfc2bb4a053ea9997dadbb681a636cb0
     *
     * @return    the parameters value identified by the transferred index as
     *            a String.
     **/
    const String getParameterText(int index) override;
    
    /**
     * Sets the parameter indexed by the transferred parameter parameterIndex
     * to the value of the transferred parameter newValue.
     *
     * The parameterIndex values will index the following parameters:
     *
     * 0 -> X Position
     * 1 -> Y Position
     * 2 -> Gain
     * 3 -> Orientation !Warning! This parameter is currently only readable.
     *      Calling this method to set this parameter will not change the
     *      parameter.
     * 4 -> Mute
     * 5 -> Model Point
     * 6 -> Fixed
     *
     * Please see the Source class for more detailed information on the
     * parameters.
     *
     * @see source.h
     *
     * Furthermore, this method calls the update_ssr(...) method to update the
     * SSR with the correlating update specificator.
     *
     * @see void update_ssr(SSR::Update_specificator specificator)
     *
     * JUCE Doc.:
     *
     * The host will call this method to change the value of one of the filter's
     * parameters.
     *
     * The host may call this at any time, including during the audio processing
     * callback, so the filter has to process this very fast and avoid blocking.
     *
     * If you want to set the value of a parameter internally, e.g. from your
     * editor component, then don't call this directly - instead, use the
     * setParameterNotifyingHost() method, which will also send a message to the
     * host telling it about the change. If the message isn't sent, the host
     * won't be able to automate your parameters properly.
     *
     * The value passed will be between 0 and 1.0.
     *
     * NOTE! This method will eventually be deprecated! It's recommended that you
     * use AudioProcessorParameter::setValue() instead.
     *
     * @param     parameterIndex  Index of the parameter that shall be set to
     *                            the newValue.
     *
     * @param     newValue        The new value to which the parameter shall be
     *                            set to.
     */
    void setParameter(int parameterIndex, float newValue) override;
    
    //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    // The following methods are own declarations
    //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    
//    SSR::Scene get_scene() const;
    float get_reference_orientation() const;
    /**
     * Returns the current selected source.
     *
     * @return the current selected source.
     */
    SSR::Source get_source() const;
    
    /**
     * Sets the discrete X position of the current selected source to
     * the transferred position and updates the SSR.
     *
     * @param           position        The new discrete X position the
     *                                  current selected source shall be
     *                                  set to.
     */
    void set_x_position_discrete_of_selected_source(const float position);
    
    /**
     * Sets the discrete Y position of the current selected source to
     * the transferred position and updates the SSR.
     *
     * @param           position        The new discrete Y position the
     *                                  current selected source shall be
     *                                  set to.
     */
    void set_y_position_discrete_of_selected_source(const float position);
    
    /**
     * Sets the discrete gain value of the current selected source to the
     * transferred gain and updates the SSR. The additional transferred
     * linear value determines whether the gain value is linear (true) or not
     * (false).
     *
     * @param           gain            The new discrete gain the current
     *                                  selected source shall be set to.
     *
     * @param           linear          Determines if the transferred gain
     *                                  value is linear (true) or not (false).
     */
    void set_gain_discrete_of_selected_source(const float gain, const bool linear);
    
    /**
     * Sets the discrete mute value of the current selected source to the
     * transferred mute value and updates the SSR.
     *
     * @param           mute            The new value the current selected
     *                                  source parameter mute shall be set to.
     */
    void set_mute_discrete_of_selected_source(const bool mute);
    
    /**
     * Sets the discrete source model of the current selected source where the
     * transferred parameter point determines whether it is a point source
     * (true) or a plane source (false) and updates the SSR.
     *
     * @param           point           Determines whether the source is point
     *                                  (true) or plane (false).
     */
    void set_model_point_discrete_of_selected_source(const bool point);
    
    /**
     * Sets the discrete value of the current selected source where the
     * transferred parameter fixed determines whether the source is
     * fixed (true) or movable (false) and updates the SSR.
     *
     * @param           fixed           Determines whether the source shall
     *                                  be fixed (true) or movable (false).
     */
    void set_fixed_discrete_of_selected_source(const bool fixed);
    
    /**
     * Sets the name of the current selected source to the transferred
     * parameter name and updates the SSR.
     *
     * @param           name            The name the current selected source
     *                                  shall be set to.
     */
    void set_name_of_selected_source(const std::string name);
    
    /**
     * Sets the properties file of the current selected source to the
     * transferred parameter prop_file and updates the SSR.
     *
     * @param           prop_file       The properties file the current
     *                                  selected source shall be set to.
     */
    void set_properties_file_of_selected_source(const std::string value);
    
    /**
     * Sets the jackport of the current selected source to the transferred
     * parameter jackport and updates the SSR.
     *
     * @param           jackport        The jackport the current selected
     *                                  source shall be set to.
     */
    void set_jackport_of_selected_source(const std::string jackport);
    
    /**
     * Changes the current selected source to the source with the transferred
     * id and returns if the selection was successful.
     *
     * @param           id              The id of the source that shall be
     *                                  selected.
     *
     * @return          true if the selection was successful, false otherwise.
     */
    bool select_source(const int id);
    
    /**
     * Creates a new source with a random generated name which will be composed
     * as follows:
     *
     * SourceXXXXX
     *
     * X -> Any character from A to Z (capitalized).
     *
     * After creating the new source, the new source will be the current selected
     * source and the SSR will be updated.
     */
    void new_source();

    /**
     * Saves the xml file with positions
     *
     *
     */
    void save_xml(const bool write);

    
    /**
     * This method reads the incoming message from the SSR server, interprets
     * them and updates the members if there have been any request of doing so
     * from the SSR server.
     *
     * @return       if there was any message from the SSR server to interpret.
     **/
    bool read_ssr_incoming_message();
    
    /**
     * This method will try to connect to the SSR with the data given by the
     * XML config file (which data will be loaded every time this method is
     * called).
     */
    void connect();
    
    /**
     * Returns true if the connection to SSR is established.
     *
     * @return true if the connection to SSR is established.
     **/
    bool is_connected_to_ssr() const;

    /**
     * Returns true if the UI needs update.
     *
     * @return true if the UI needs update.
     **/
    bool is_writing_xml() const;
    
    /**
     * Returns true if the UI needs update.
     *
     * @return true if the UI needs update.
     **/
    bool ui_needs_update() const;
    
    /**
     * Sets the ui_update_flag to true for requesting a UI update.
     **/
    void ui_request_update();
    
    /**
     * Clears the ui_update_flag by setting it tp false.
     **/
    void ui_clear_update_flag();
    
    /**
     * This method returns all Jack Ports specified by the flags. If there are no
     * jackports available, the method will return a vector with one element
     * which content is "No Jackport available.".
     *
     * Furthermore, the method will log an error an error occurs.
     *
     * @param    flags       Flags to specify which Jack Ports shall be returned.
     *                       See JackPortFlags (jack/types.h) for all flags you can
     *                       set.
     *
     * @return   all jackports specified by the flags.
     **/
    std::vector<std::string> get_all_jack_ports(const unsigned long flags);
    
    /**
     * This method will update the SSR by composing a string with all information
     * needed for updating the parameters specified by the specificator.
     *
     * Finally, the method will send the new composed message to the SSR.
     *
     * @see update_specificator.h
     * @see ssr_requester.h
     *
     * @param     specificator    The specificator specifying the parameters
     *                            which shall be updated.
     */
    void update_ssr(SSR::Update_specificator specificator);
    
    /**
     * Creates a vector with the sources ids and names and returns it.
     *
     * @return the sources ids and names.
     */
    std::shared_ptr< std::vector< std::pair<unsigned int, std::string> > > get_source_ids_and_names();
    
    
private:
    
    /**
     * Start Writitng XML
     **/
    bool write_xml();
    
    /**
     * Sends the message_to_ssr to the SSR and sets the message_to_ssr to empty
     * string.
     **/
    void send_message_to_ssr();
    
    /**
     * Returns a the valid config file path (including the file name).
     * The file path is concatenated as follows:
     *
     * 1.   The config file path is loaded by the currently set environment variable
     *      $SSREMOTE_CONFIG
     * 2.   The name of the config file: ssremote_config.xml
     *
     * Those two components are concatenated to one file path which should be valid.
     * If the path is not valid, there will be a console output to std::cerr.
     *
     * TODO: Should there be any mechanic to create the file if it does not exist?
     *
     * @return a the valid config file path (including the file name).
     */
    boost::filesystem::path get_config_file_path();


private:
    //==============================================================================
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (Controller)
    
    
    /**
     * File to save
     **/
    File* xml_file;
    
    /**
     * Pointer to spatdif element
     **/
    ScopedPointer<XmlElement> spatdif;
    
    
    /**
     * Store playhead
     **/
    double playback_time;
    
    /**
     * Toogle save xml;
     **/
    bool writing_xml;
    
    /**
     * Bool flag indicating if the user interface needs to be updated (= true).
     **/
    bool ui_update_flag;
    
    /**
     * TCP connection object for connecting to ssr.
     **/
    std::unique_ptr<SSR::IConnection> tcp_connection;
    
    /**
     * The message that will be send to the SSR server.
     * It has to include the '\0' also called EOF ending so the SSR server understands
     * that this is the end of the message.
     **/
    std::shared_ptr<std::string> message_to_ssr;
    
    /**
     * The message that comes from the SSR server.
     * It has to have an '\0' at the end.
     **/
    std::shared_ptr<std::string> message_from_ssr;
    
    /**
     * The jack client managing the provided jack ports.
     */
    std::unique_ptr<SSR::Jack_client> jack_client;
    
    /**
     * This is the SSR requester, requesting changes of the SSR scene.
     */
    std::unique_ptr<SSR::SSR_requester> requester;
    
    /**
     * The config for this VST Plugin.
     */
    std::unique_ptr<SSR::Config> config;
    
    /**
     * The scene with all related sources and additional information.
     */
    std::unique_ptr< SSR::Scene > scene;
};


#endif  // PLUGINPROCESSOR_H_INCLUDED
