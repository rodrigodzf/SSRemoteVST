/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include <src/controller.h>
#include <src/GUI/main_gui_component.h>
//Boost
#include <boost/lexical_cast.hpp>
#include <boost/algorithm/string/join.hpp>
#include <boost/range/adaptor/transformed.hpp>
//Own Libs
#include <src/utils/jack_client.h>
#include <src/utils/tcp_connection.h>
#include <src/utils/ssr_requester.h>
#include <src/utils/helper.h>
#include <src/utils/update_specificator.h>
#include <src/config/config.h>
#include <src/scene/scene.h>
#include <src/scene/source.h>
#include <src/utils/random_machine.h>
#include <src/utils/logger.h>

#define LOG_TO_FILE 0


//==============================================================================
Controller::Controller()
: ui_update_flag(true)
, writing_xml(false)
, tcp_connection(nullptr)
, message_to_ssr(new std::string(""))
, message_from_ssr(new std::string(""))
, jack_client(new SSR::Jack_client())
, requester(new SSR::SSR_requester())
, config(nullptr)
, scene(new SSR::Scene(20.0f))

{
    
//    if(const char* env_p = std::getenv("SSRRemote_FromScrath"))
//        std::cout << "Your PATH is: " << env_p << '\n';
    
    SSR::Logger::get_instance()->log(SSR::Logger::Level::INFO, "Constructor of Controller was called!", false);
    SSR::Logger::get_instance()->log(SSR::Logger::Level::INFO, "Build: 6", false);

    boost::filesystem::path config_file = get_config_file_path();
    config = std::unique_ptr<SSR::Config>(new SSR::Config(config_file));
    config->load_config_xml_file();
    
    connect();

    const char* jack_client_name = JucePlugin_Name;
    
    try {
        jack_client->register_client(jack_client_name);
    } catch (SSR::jack_server_not_running_exception& jsnre) {
        SSR::Logger::get_instance()->log(SSR::Logger::Level::ERROR, jsnre.what(), LOG_TO_FILE);
    } catch (std::exception& e) {
        SSR::Logger::get_instance()->log(SSR::Logger::Level::ERROR, e.what(), LOG_TO_FILE);
    }
    
    // TODO: shouldnt this be in a separate thread?
    read_ssr_incoming_message();
    
    
}

Controller::~Controller(){}

//==============================================================================
const String Controller::getName() const
{
    return JucePlugin_Name;
}

const String Controller::getInputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

const String Controller::getOutputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

bool Controller::isInputChannelStereoPair (int index) const
{
    return true;
}

bool Controller::isOutputChannelStereoPair (int index) const
{
    return true;
}

bool Controller::acceptsMidi() const
{
   #if JucePlugin_WantsMidiInput
    return true;
   #else
    return false;
   #endif
}

bool Controller::producesMidi() const
{
   #if JucePlugin_ProducesMidiOutput
    return true;
   #else
    return false;
   #endif
}

bool Controller::silenceInProducesSilenceOut() const
{
    return false;
}

double Controller::getTailLengthSeconds() const
{
    return 0.0;
}

int Controller::getNumPrograms()
{
    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
                // so this should be at least 1, even if you're not really implementing programs.
}

int Controller::getCurrentProgram()
{
    return 0;
}

void Controller::setCurrentProgram (int index)
{
}

const String Controller::getProgramName (int index)
{
    return String();
}

void Controller::changeProgramName (int index, const String& newName)
{
}

//==============================================================================
void Controller::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    // Use this method as the place to do any pre-playback
    // initialisation that you need..
}

void Controller::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
}

void Controller::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
    // In case we have more outputs than inputs, this code clears any output
    // channels that didn't contain input data, (because these aren't
    // guaranteed to be empty - they may contain garbage).
    // I've added this to avoid people getting screaming feedback
    // when they first compile the plugin, but obviously you don't need to
    // this code if your algorithm already fills all the output channels.
    for (int i = getNumInputChannels(); i < getNumOutputChannels(); ++i)
        buffer.clear (i, 0, buffer.getNumSamples());

    // This is the place where you'd normally do the guts of your plugin's
    // audio processing...
//    for (int channel = 0; channel < getNumInputChannels(); ++channel)
//    {
//        float* channelData = buffer.getWritePointer (channel);
//
//        // ..do something to the data...
//    }
    
    /*
     *
     */
    
    // TODO: think about moving this somewhere else; not sure if we need ultra high resolution
    // Also we cannot getCurrentPosition info anywhere else;
    // Also it needs an scopedpointer http://www.juce.com/forum/topic/strange-problem-using-xmlelement-objects
    // Also might be easier to use tree value http://www.juce.com/forum/topic/value-valuetree-example-usage
    
    AudioPlayHead::CurrentPositionInfo info;
    getPlayHead()->getCurrentPosition(info);

    
    if (playback_time != info.timeInSeconds){
        if (writing_xml) {
            
            write_xml();
            
        }
    }
    
    playback_time = info.timeInSeconds;

    
    
    
//  std::cout << "time ins secs " << info.timeInSeconds << std::endl;
}


//==============================================================================
bool Controller::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* Controller::createEditor()
{
    return new Main_GUI_component (this);
}

//==============================================================================
void Controller::getStateInformation (MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // You could do that either as raw data, or use the XML or ValueTree classes
    // as intermediaries to make it easy to save and load complex data.
}

void Controller::setStateInformation (const void* data, int sizeInBytes)
{
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new Controller();
}
//==============================================================================
// Deprecations

int Controller::getNumParameters() {
//    SSR::Logger::get_instance()->log(SSR::Logger::Level::INFO, "ParamCount" + int(SSR::Source::parameter::parameter_count), false);
    
//    std::cout << "Parameters " << (int)SSR::Source::parameter::parameter_count << std::endl;
    return (int)SSR::Source::parameter::parameter_count;
    
}

const juce::String Controller::getParameterName(int parameterIndex)
{
    typedef SSR::Source::parameter source_parameter;
    
    std::string parameter_name = "No Name Specified";
    
    switch (parameterIndex)
    {
        case source_parameter::x_position_idx:
            parameter_name = scene->get_x_position_of_selected_source().get_name();
            break;
            
        case source_parameter::y_position_idx:
            parameter_name = scene->get_y_position_of_selected_source().get_name();
            break;
            
        case source_parameter::gain_idx:
            parameter_name = scene->get_gain_of_selected_source().get_name();
            break;
            
        case source_parameter::orientation_idx:
            parameter_name = scene->get_orientation_of_selected_source().get_name();
            break;
            
        case source_parameter::mute_idx:
            parameter_name = scene->get_mute_of_selected_source().get_name();
            break;
            
        case source_parameter::model_point_idx:
            parameter_name = scene->get_model_point_of_selected_source().get_name();
            break;
            
        case source_parameter::fixed_idx:
            parameter_name = scene->get_fixed_of_selected_source().get_name();
            break;
            
        case source_parameter::save_idx:
            parameter_name = "Save Toggle";
            break;
            
        default:
            break;
            
    }
    
    return juce::String(parameter_name);
}

int Controller::getParameterNumSteps(int index)
{
    
    typedef SSR::Source::parameter source_parameter;
    int is_boolean = 2;
    int ret;
    
    switch (index) {
        case source_parameter::mute_idx:
            ret = is_boolean;
            break;
            
        case source_parameter::fixed_idx:
            ret = is_boolean;
            break;
        case source_parameter::save_idx:
            ret = is_boolean;
            break;
            
        default:
            break;
    }
    
    return ret;
    

}
float Controller::getParameter(int index)
{
    typedef SSR::Source::parameter source_parameter;
    
    float parameter_as_float = 0.0f;
    
    switch (index)
    {
        case source_parameter::x_position_idx:
            parameter_as_float = scene->get_x_position_of_selected_source().get_continuous_value();
            break;
            
        case source_parameter::y_position_idx:
            parameter_as_float = scene->get_y_position_of_selected_source().get_continuous_value();
            break;
            
        case source_parameter::gain_idx:
            parameter_as_float = scene->get_gain_of_selected_source().get_continuous_value();
            break;
            
        case source_parameter::orientation_idx:
            parameter_as_float = scene->get_orientation_of_selected_source().get_continuous_value();
            break;
            
        case source_parameter::mute_idx:
            parameter_as_float = scene->get_mute_of_selected_source().get_continuous_value();
            break;
            
        case source_parameter::model_point_idx:
            parameter_as_float = scene->get_model_point_of_selected_source().get_continuous_value();
            break;
            
        case source_parameter::fixed_idx:
            parameter_as_float = scene->get_fixed_of_selected_source().get_continuous_value();
            break;
            
        case source_parameter::save_idx:
            parameter_as_float = (float)writing_xml;
            break;
            
        default:
            break;
            
    }
    
    return parameter_as_float;
}

const juce::String Controller::getParameterText(int index)
{
    typedef SSR::Source::parameter source_parameter;
    
    std::string parameter_text = "0.0";
    
    switch (index)
    {
        case source_parameter::x_position_idx:
            parameter_text = scene->get_x_position_of_selected_source().get_continuous_value();
            break;
            
        case source_parameter::y_position_idx:
            parameter_text = scene->get_y_position_of_selected_source().get_continuous_value();
            break;
            
        case source_parameter::gain_idx:
            parameter_text = scene->get_gain_of_selected_source().get_continuous_value();
            break;
            
        case source_parameter::orientation_idx:
            parameter_text = scene->get_orientation_of_selected_source().get_continuous_value();
            break;
            
        case source_parameter::mute_idx:
            parameter_text = scene->get_mute_of_selected_source().get_continuous_value();
            break;
            
        case source_parameter::model_point_idx:
            parameter_text = scene->get_model_point_of_selected_source().get_continuous_value();
            break;
            
        case source_parameter::fixed_idx:
            parameter_text = scene->get_fixed_of_selected_source().get_continuous_value();
            break;
            
        case source_parameter::save_idx:
            parameter_text = "Save State";
            break;
            
        default:
            break;
            
    }
    
    return juce::String(parameter_text);
}

void Controller::setParameter(int parameterIndex, float newValue)
{
    typedef SSR::Source::parameter source_parameter;
    typedef SSR::Update_specificator::Specificators update_specificators;
    
    SSR::Update_specificator specificator { update_specificators::position };
    
    switch (parameterIndex)
    {
        case source_parameter::x_position_idx:
//            std::cout << "Position X " << newValue << std::endl;
            scene->set_x_position_continuous_of_selected_source(newValue);
            break;
            
        case source_parameter::y_position_idx:
            scene->set_y_position_continuous_of_selected_source(newValue);
            break;
            
        case source_parameter::gain_idx:
            scene->set_gain_continuous_of_selected_source(newValue);
            specificator = update_specificators::gain;
            break;
            
        case source_parameter::orientation_idx:
            //TODO: Not possible for now!
            break;
            
        case source_parameter::mute_idx:
            scene->set_mute_continuous_of_selected_source(newValue);
            specificator = update_specificators::mute;
            break;
            
        case source_parameter::model_point_idx:
            scene->set_model_point_continuous_of_selected_source(newValue);
            specificator = update_specificators::model;
            break;
            
        case source_parameter::fixed_idx:
            scene->set_fixed_continuous_of_selected_source(newValue);
            specificator = update_specificators::fixed;
            break;
            
        case source_parameter::save_idx:
            if (newValue > 0.5f){
                save_xml(true);
            } else {
                save_xml(false);
            }
            
            // TODO:Need to update GUI
            
            break;
            
            
        default:
            break;
            
    }
    
    update_ssr(specificator);
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// The following methods are own implementations
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//TODO:get_scene
//SSR::Scene Controller::get_scene() const
//{
//    scene-get
//    return *new SSR::Scene(10.0f);
////    return *scene.get();
//
//}
bool Controller::is_writing_xml() const
{
    return writing_xml;
}
float Controller::get_reference_orientation() const
{

    return scene->get_reference_orientation().get_discrete_value();
}

SSR::Source Controller::get_source() const
{
    return scene->get_source();
}

void Controller::set_x_position_discrete_of_selected_source(const float position)
{
    scene->set_x_position_discrete_of_selected_source(position);
    update_ssr(SSR::Update_specificator(SSR::Update_specificator::Specificators::position));
    ui_update_flag = true;
}

void Controller::set_y_position_discrete_of_selected_source(const float position)
{
    scene->set_y_position_discrete_of_selected_source(position);
    update_ssr(SSR::Update_specificator(SSR::Update_specificator::Specificators::position));
    ui_update_flag = true;
}

void Controller::set_gain_discrete_of_selected_source(const float gain, const bool linear)
{
    scene->set_gain_discrete_of_selected_source(gain, linear);
    update_ssr(SSR::Update_specificator(SSR::Update_specificator::Specificators::gain));
    ui_update_flag = true;
}

void Controller::set_mute_discrete_of_selected_source(const bool mute)
{
    scene->set_mute_discrete_of_selected_source(mute);
    update_ssr(SSR::Update_specificator(SSR::Update_specificator::mute));
    ui_update_flag = true;
}

void Controller::set_model_point_discrete_of_selected_source(const bool point)
{
    scene->set_model_point_discrete_of_selected_source(point);
    update_ssr(SSR::Update_specificator(SSR::Update_specificator::model));
    ui_update_flag = true;
}

void Controller::set_fixed_discrete_of_selected_source(const bool fixed)
{
    scene->set_fixed_discrete_of_selected_source(fixed);
    update_ssr(SSR::Update_specificator(SSR::Update_specificator::fixed));
    ui_update_flag = true;
}

void Controller::set_name_of_selected_source(const std::string name)
{
    scene->set_name_of_selected_source(name);
    update_ssr(SSR::Update_specificator(SSR::Update_specificator::name));
    ui_update_flag = true;
}

void Controller::set_properties_file_of_selected_source(const std::string value)
{
    scene->set_properties_file_of_selected_source(value);
    update_ssr(SSR::Update_specificator(SSR::Update_specificator::properties_file));
    ui_update_flag = true;
}

void Controller::set_jackport_of_selected_source(const std::string jackport)
{
    scene->set_jackport_of_selected_source(jackport);
    update_ssr(SSR::Update_specificator(SSR::Update_specificator::port));
    ui_update_flag = true;
}

bool Controller::select_source(const int id)
{
    return scene->select_source(id);
}

void Controller::new_source()
{
    unsigned int id = scene->new_source("Source" + SSR::Random_machine::get_instance()->generate_string(5, 'A', 'Z'));
    update_ssr(SSR::Update_specificator(SSR::Update_specificator::new_source));
    ui_update_flag = true;
}

bool Controller::write_xml()
{
    
    // create an inner elements..
    XmlElement* time        = new XmlElement ("time");
    XmlElement* source      = new XmlElement ("source");
    XmlElement* name        = new XmlElement ("name");
    XmlElement* position    = new XmlElement ("position");
    
    //        boost::lexical_cast<std::string>
    time->addTextElement(boost::lexical_cast<std::string>(playback_time));
    
    name->addTextElement(scene->get_source().get_name());
    
    
    float posx = scene->get_x_position_of_selected_source().get_discrete_value();
    float posy = scene->get_y_position_of_selected_source().get_discrete_value();
    float posz = 0.0f;
    
    std::vector<float> position_vector{posx,posy,posz};
    std::string sPositionVector = boost::algorithm::join(position_vector | boost::adaptors::transformed( static_cast<std::string(*)(double)>(std::to_string) ), " " );
    
    position->addTextElement(sPositionVector);
    
    // Prepend child element is less heavy on CPU
    source->addChildElement(name);
    source->addChildElement(position);
    
    // source->setAttribute("position", scene->get_x_position_of_selected_source().get_continuous_value());
    // ..and add our new element to the parent node
    
    spatdif->addChildElement(time);
    spatdif->addChildElement(source);
    
    // now we can turn the whole thing into a text document..
    // String myXmlDoc = time.createDocument (String::empty);
    
    // I guess this should be asserting that everything is alright?
    return true;

}

void Controller::save_xml(const bool write)
{
    
    if (write){
        
        writing_xml = true;

        xml_file = new File(File::getCurrentWorkingDirectory().getChildFile("./TestJuce.xml"));
        String absolute_path = xml_file->getFullPathName();
        SSR::Logger::get_instance()->log(SSR::Logger::Level::INFO, "Saving File to" + absolute_path.toStdString(), LOG_TO_FILE);
        
        spatdif = new XmlElement("spatdif");
        
        
        /*
         This is the meta section at the beggining of the xml file:
         
        <meta>
         <info>
            <annotation>the turenas insect trajectory</annotation>
            <date>2013-10-17</date>
            <author>jasch</author>
        </info>
        <extensions>media</extensions>
        <ordering>time</ordering>
        </meta>
         */
        
        XmlElement* meta            = new XmlElement ("meta");
        XmlElement* info            = new XmlElement ("info");
        XmlElement* ordering        = new XmlElement ("ordering");
        
        XmlElement* annotation      = new XmlElement ("annotation");
        XmlElement* date            = new XmlElement ("date");
        XmlElement* author          = new XmlElement ("author");
        
        
        annotation->addTextElement("Scene from SSR");
        date->addTextElement("2015-01-03");
        author->addTextElement("RDiaz");
        
        info->addChildElement(annotation);
        info->addChildElement(date);
        info->addChildElement(author);
        
        meta->addChildElement(info);
        meta->addChildElement(ordering);
        
        spatdif->addChildElement(meta);
        
    } else {
        
        writing_xml = false;
        
        if (xml_file != nullptr){
            
            if(spatdif->writeToFile(*xml_file, String::empty)){
                delete xml_file;
            };
        }
    }
}

bool Controller::read_ssr_incoming_message()
{
    int wait_in_msec = 0;
    
    bool message_incoming = false;
    
    while (tcp_connection->get_message(message_from_ssr, &wait_in_msec)) {
        scene->interpret_xml_message(*message_from_ssr);
        ui_update_flag = true;
        message_incoming = true;
    }
    
    return message_incoming;
}

void Controller::connect()
{
    config->load_config_xml_file();
    
    std::string hostname = config->get_network_config().get_hostname();
    unsigned int port = config->get_network_config().get_port();
    unsigned int timeout_in_ms = config->get_network_config().get_timeout();
    
    tcp_connection = std::unique_ptr<SSR::TCP_connection>(new SSR::TCP_connection(hostname, port, timeout_in_ms, '\0'));
    
    tcp_connection->connect();
}

bool Controller::is_connected_to_ssr() const
{
    return tcp_connection->is_connected();
}

bool Controller::ui_needs_update() const
{
    return ui_update_flag;
}

void Controller::ui_request_update()
{
    ui_update_flag = true;
}

void Controller::ui_clear_update_flag()
{
    ui_update_flag = false;
}

std::vector<std::string> Controller::get_all_jack_ports(const unsigned long flags)
{
    std::vector<std::string> available_jack_ports;
    available_jack_ports.push_back(std::string("No Jackport available."));
    
    try {
        available_jack_ports = jack_client->look_up_jack_ports(flags);
    } catch (SSR::jack_server_not_running_exception& jsnre) {
        SSR::Logger::get_instance()->log(SSR::Logger::Level::ERROR, jsnre.what(), LOG_TO_FILE);
    } catch (std::exception& e) {
        SSR::Logger::get_instance()->log(SSR::Logger::Level::ERROR, e.what(), LOG_TO_FILE);
    }
    
    return available_jack_ports;
}

void Controller::update_ssr(SSR::Update_specificator specificator)
{
    
    switch (specificator.get_spec()) {
            
        case SSR::Update_specificator::Specificators::gain:
            
            //Importtant: Source Gain param is stored as linear value, so it has to be
            //converted to dB befor sending a request to change it
            *message_to_ssr = requester->build(std::bind(
                                                         SSR::request::source_gain,
                                                         std::placeholders::_1,
                                                         scene->get_id_of_selected_source(),
                                                         SSR::helper::linear_to_dB(scene->get_gain_of_selected_source().get_discrete_value())
                                                         ));
            break;
            
        case SSR::Update_specificator::Specificators::position:
            *message_to_ssr = requester->build(std::bind(
                                                         SSR::request::source_position,
                                                         std::placeholders::_1,
                                                         scene->get_id_of_selected_source(),
                                                         scene->get_x_position_of_selected_source().get_discrete_value(),
                                                         scene->get_y_position_of_selected_source().get_discrete_value()
                                                         ));
            break;
            
        case SSR::Update_specificator::Specificators::mute:
            *message_to_ssr = requester->build(std::bind(
                                                         SSR::request::source_mute,
                                                         std::placeholders::_1,
                                                         scene->get_id_of_selected_source(),
                                                         scene->get_mute_of_selected_source().get_discrete_value()
                                                         ));
            break;
            
        case SSR::Update_specificator::Specificators::fixed:
            *message_to_ssr = requester->build(std::bind(
                                                         SSR::request::source_fixed,
                                                         std::placeholders::_1,
                                                         scene->get_id_of_selected_source(),
                                                         scene->get_fixed_of_selected_source().get_discrete_value()
                                                         ));
            break;
            
        case SSR::Update_specificator::Specificators::model:
            
            *message_to_ssr = requester->build(std::bind(
                                                         SSR::request::source_model,
                                                         std::placeholders::_1,
                                                         scene->get_id_of_selected_source(),
                                                         scene->get_model_point_of_selected_source().get_discrete_value() ? "point" : "plane"
                                                         ));
            break;
            
        case SSR::Update_specificator::Specificators::name:
            
            *message_to_ssr = requester->build(std::bind(
                                                         SSR::request::source_name,
                                                         std::placeholders::_1,
                                                         scene->get_id_of_selected_source(),
                                                         scene->get_name_of_selected_source()
                                                         ));
            break;
            
        case SSR::Update_specificator::Specificators::properties_file:
            *message_to_ssr = requester->build(std::bind(
                                                         SSR::request::source_properties_file,
                                                         std::placeholders::_1,
                                                         scene->get_id_of_selected_source(),
                                                         scene->get_properties_file_of_selected_source()
                                                         ));
            break;
            
        case SSR::Update_specificator::Specificators::port:
            *message_to_ssr = requester->build(std::bind(
                                                         SSR::request::source_port,
                                                         std::placeholders::_1,
                                                         scene->get_id_of_selected_source(),
                                                         scene->get_jackport_of_selected_source()
                                                         ));
            break;
            
        case SSR::Update_specificator::Specificators::new_source:
            *message_to_ssr = requester->build(std::bind(
                                                         SSR::request::new_source,
                                                         std::placeholders::_1,
                                                         scene->get_name_of_selected_source(),
                                                         scene->get_jackport_of_selected_source(),
                                                         scene->get_x_position_of_selected_source().get_discrete_value(),
                                                         scene->get_y_position_of_selected_source().get_discrete_value()
                                                         ));
            break;
            
        default:
            break;
            
    }
    
    send_message_to_ssr();
}

std::shared_ptr< std::vector< std::pair<unsigned int, std::string> > > Controller::get_source_ids_and_names()
{
    return scene->get_source_ids_and_names();
}
//==============================================================================
// PRIVATE METHODS
//==============================================================================

void Controller::send_message_to_ssr()
{
    tcp_connection->send_message(message_to_ssr, 0x00);
    
    //Reset message to empty string after sending the message
    *message_to_ssr = std::string("");
}

boost::filesystem::path Controller::get_config_file_path()
{
    SSR::Logger::get_instance()->log(SSR::Logger::Level::ERROR, "get_config_file_path", false);

    namespace bfs = boost::filesystem;
    bfs::path config_file_location;
    
    /* TODO:fix xml location

    try {
        config_file_location = SSR::helper::get_environment_variable("SSREMOTE_VST");
    } catch (std::invalid_argument& iae) {
        SSR::Logger::get_instance()->log(SSR::Logger::Level::ERROR, iae.what(), LOG_TO_FILE);
    }
    
    if (!bfs::is_directory(config_file_location)) {
        SSR::Logger::get_instance()->log(SSR::Logger::Level::ERROR, "Configfile location is not a directory!", LOG_TO_FILE);
    }
    
    */
    std::string filename = "ssremote_config.xml";
    
//    boost::filesystem::path config_file_path = config_file_location / bfs::path(filename);
    boost::filesystem::path config_file_path = bfs::path(filename);

    
    if (!bfs::is_regular_file(config_file_path)) {
        SSR::Logger::get_instance()->log(SSR::Logger::Level::ERROR, "Configfile is not a regular file!", LOG_TO_FILE);
    }
    
    return config_file_path;
}

